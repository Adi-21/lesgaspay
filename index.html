<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI NFT Creator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: #f3f4f6;
        }

        .gradient-bg {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        }

        .card {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 24px;
            margin-bottom: 24px;
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 12px -1px rgba(0, 0, 0, 0.15);
        }

        .btn-primary {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .btn-primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            background: #d1d5db;
            cursor: not-allowed;
            transform: none;
        }

        .input-field {
            width: 100%;
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 16px;
            transition: border-color 0.2s;
        }

        .input-field:focus {
            outline: none;
            border-color: #6366f1;
        }

        .preview-image {
            width: 100%;
            height: 300px;
            object-fit: cover;
            border-radius: 8px;
            border: 2px dashed #e5e7eb;
            background: #f8fafc;
        }

        .loading {
            position: relative;
        }

        .loading::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
        }

        #telegram-login {
            display: flex;
            align-items: center;
        }

        #telegram-login iframe {
            margin: 0;
        }
    </style>
    <script>
        // Define Telegram auth functions globally
        window.onTelegramAuth = function (user) {
            console.log('Telegram user:', user);
            window.telegramUser = user;

            // Store Telegram user data
            localStorage.setItem('telegramUser', JSON.stringify(user));

            // Enable wallet setup buttons
            document.getElementById('createWalletBtn').disabled = false;
            document.getElementById('importWalletBtn').disabled = false;

            // Update UI to show logged-in user
            updateLoginStatus(user);
        }

        function updateLoginStatus(user) {
            const walletInfo = document.getElementById('walletInfo');
            // if (user) {
            //     walletInfo.innerHTML = `
            //         <div class="flex items-center gap-2">
            //             <img src="${user.photo_url}" alt="${user.first_name}" 
            //                 class="w-8 h-8 rounded-full">
            //             <span>${user.first_name}</span>
            //         </div>
            //     `;
            // }
        }

        // Check for existing Telegram login on page load
        document.addEventListener('DOMContentLoaded', () => {
            const savedUser = localStorage.getItem('telegramUser');
            if (savedUser) {
                window.telegramUser = JSON.parse(savedUser);
                updateLoginStatus(window.telegramUser);
            } else {
                // Disable wallet buttons until logged in
                document.getElementById('createWalletBtn').disabled = true;
                document.getElementById('importWalletBtn').disabled = true;
            }
        });
    </script>
</head>

<body class="min-h-screen pb-8">
    <nav class="gradient-bg text-white p-4 mb-8">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-2xl font-bold">AI NFT Creator</h1>
            <div class="flex items-center gap-4">
                <div id="walletInfo" class="text-sm"></div>
                <!-- Telegram Login Widget -->
                <div id="telegram-login">
                    <script async src="https://telegram.org/js/telegram-widget.js?22"
                        data-telegram-login="cheesecakeverify_bot" data-size="medium" data-onauth="onTelegramAuth(user)"
                        data-request-access="write">
                        </script>
                </div>
            </div>
        </div>
    </nav>

    <main class="container mx-auto px-4 max-w-4xl">

        <div class="card" id="chainSelect">
            <h2 class="text-xl font-bold mb-4">‚õìÔ∏è Select Chain</h2>
            <select id="chainSelector" class="input-field">
                <option value="">Select Network</option>
                <option value="AVALANCHE">Avalanche</option>
                <option value="MOONBEAM">Moonbeam</option>
                <option value="BASE">Base</option>
                <option value="ETHEREUM">Ethereum</option>
                <option value="POLYGON">Polygon</option>
                <option value="METIS">Metis</option>
                <option value="FANTOM">Fantom</option>
            </select>
            <div class="mt-2 text-sm font-medium">
                Current Network: <span id="networkDisplay" class="text-purple-600">Not Selected</span>
            </div>
        </div>

        <!-- Wallet Setup -->
        <div class="card" id="walletSetup">
            <h2 class="text-xl font-bold mb-4">üîê Wallet Setup</h2>
            <div class="flex gap-4 flex-wrap">
                <button onclick="connectMetamask()" id="connectMetamaskBtn" class="btn-primary" disabled>
                    Connect Metamask
                </button>
                <button onclick="window.createNewWallet()" id="createWalletBtn" class="btn-primary">
                    Create New Wallet
                </button>
                <button onclick="window.importWallet()" id="importWalletBtn" class="btn-primary">
                    Import Wallet
                </button>
            </div>
            <input type="text" id="privateKey" placeholder="Enter your private key (with 0x prefix)"
                class="input-field mt-4" style="display: none;">
            <div id="walletDetails" class="mt-4 text-sm text-gray-600"></div>
        </div>

        <!-- Smart Account Setup -->
        <div class="card" id="smartAccountSetup">
            <h2 class="text-xl font-bold mb-4">üîë Smart Account Setup</h2>
            <button onclick="setupSmartAccount()" id="setupBtn" disabled class="btn-primary w-full">
                Setup Smart Account
            </button>
            <div id="smartAccountInfo" class="mt-4 text-sm text-gray-600"></div>
        </div>

        <!-- NFT Creation -->
        <div class="card" id="nftCreation">
            <h2 class="text-xl font-bold mb-4">üé® Create AI-Generated NFT</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <textarea id="promptInput" placeholder="Describe your NFT artwork in detail..." class="input-field"
                        rows="4"></textarea>
                    <select id="styleSelect" class="input-field">
                        <option value="realistic">Realistic</option>
                        <option value="enhance">Enhanced</option>
                        <option value="anime">Anime</option>
                        <option value="photographic">Photographic</option>
                        <option value="digital-art">Digital Art</option>
                        <option value="comic-book">Comic Book</option>
                    </select>
                    <button onclick="generateArtwork()" id="generateBtn" class="btn-primary w-full">
                        Generate Artwork
                    </button>
                </div>
                <div>
                    <img id="artworkPreview" class="preview-image"
                        src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300' viewBox='0 0 400 300'%3E%3Crect width='400' height='300' fill='%23f8fafc'/%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' font-family='Arial' font-size='14' fill='%2394a3b8'%3EArtwork preview will appear here%3C/text%3E%3C/svg%3E"
                        alt="Artwork preview">
                </div>
            </div>
        </div>

        <!-- NFT Details -->
        <div class="card" id="nftDetails">
            <h2 class="text-xl font-bold mb-4">üìù NFT Details</h2>
            <input type="text" id="nftName" placeholder="NFT Name" class="input-field">
            <textarea id="nftDescription" placeholder="NFT Description" class="input-field" rows="3"></textarea>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium mb-2">üí∞ Base Price</label>
                    <span class="text-xs text-gray-500" id="currencySymbol"></span>
                    <input type="number" id="basePrice" placeholder="0.0" step="0.001" min="0" class="input-field">
                    <p id="priceRecommendation" class="text-sm text-purple-600"></p>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">ü§ù Royalty Split</label>
                    <div class="flex gap-2">
                        <input type="text" id="collaboratorAddress" placeholder="Collaborator Address (0x...)"
                            class="input-field flex-grow">
                        <input type="number" id="royaltyPercentage" placeholder="%" min="0" max="100"
                            class="input-field w-24">
                    </div>
                </div>
            </div>

            <button onclick="mintNFT()" id="mintBtn" class="btn-primary w-full" disabled>
                Mint NFT (Gasless)
            </button>
        </div>

        <!-- Transaction Status -->
        <div class="card" id="transactionStatus" style="display: none;">
            <h2 class="text-xl font-bold mb-4">üìä Transaction Status</h2>
            <div id="statusText" class="text-gray-600"></div>
            <div id="transactionHash" class="text-sm text-blue-600 mt-2"></div>
        </div>
    </main>

    <script type="module">
        import { createSmartAccountClient, PaymasterMode } from 'https://cdn.jsdelivr.net/npm/@0xgasless/smart-account@0.0.11/+esm';

        // Update CONFIG to use environment variables
        let CONFIG = {
            rpcUrl: "https://avax-mainnet.g.alchemy.com/v2/VcifYAbO7TUL14eUvHmbjSklgVzWEMXk",
            bundlerUrl: "https://bundler.0xgasless.com/43114",
            paymasterUrl: "https://paymaster.0xgasless.com/v1/43114/rpc/35b99953-edde-4f28-9661-c41898916471",
            chainId: 43114,
            nftContractAddress: "0xe7337B97F380A19A860068f0dACa74F50AF86548",
            pinata: {
                jwt: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiIxOTc0ZWM3ZS1hNjk5LTQzM2QtODk1MS00YTEyMDcyOGY2MzkiLCJlbWFpbCI6ImFkaXMyMTEwNEBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwicGluX3BvbGljeSI6eyJyZWdpb25zIjpbeyJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MSwiaWQiOiJGUkExIn0seyJkZXNpcmVkUmVwbGljYXRpb25Db3VudCI6MSwiaWQiOiJOWUMxIn1dLCJ2ZXJzaW9uIjoxfSwibWZhX2VuYWJsZWQiOmZhbHNlLCJzdGF0dXMiOiJBQ1RJVkUifSwiYXV0aGVudGljYXRpb25UeXBlIjoic2NvcGVkS2V5Iiwic2NvcGVkS2V5S2V5IjoiNzhjOTM3NDMwNGMzYmRjNmYyYTciLCJzY29wZWRLZXlTZWNyZXQiOiIxYTUxMzAwY2ZhYWE2ZDY0M2JkOTYyMWIxNjA3ZmViYWUwNjQzMzA4NTk3Y2EyNDBhZTdjMzk3N2FmMDI0M2RhIiwiZXhwIjoxNzY1MjkwNDEwfQ.mGeY9zom2wbgZjlKHkrDQNisAKhv93-vk_X2D2mCZow",
                apiEndpoint: 'https://api.pinata.cloud/pinning'
            }
        };

        const CHAIN_CONFIG = {
            MOONBEAM: {
                chainId: 1284,
                rpcUrl: "https://moonbeam-rpc.publicnode.com",
                bundlerUrl: "https://bundler.0xgasless.com/8780429",
                paymasterUrl: "YOUR_PAYMASTER_URL",
                nftContractAddress: "YOUR_MOONBEAM_CONTRACT",
                explorerUrl: "https://moonbeam.moonscan.io/tx/",
                nativeCurrency: {
                    name: "GLMR",
                    symbol: "GLMR",
                    decimals: 18
                }
            },
            BASE: {
                chainId: 8453,
                rpcUrl: "https://base-rpc.publicnode.com",
                bundlerUrl: "https://bundler.0xgasless.com/23821278",
                paymasterUrl: "YOUR_PAYMASTER_URL",
                nftContractAddress: "YOUR_BASE_CONTRACT",
                explorerUrl: "https://basescan.org/tx/",
                nativeCurrency: {
                    name: "ETH",
                    symbol: "ETH",
                    decimals: 18
                }
            },
            AVALANCHE: {
                chainId: 43114,
                rpcUrl: "https://avalanche-c-chain-rpc.publicnode.com",
                bundlerUrl: "https://bundler.0xgasless.com/43114",
                paymasterUrl: "https://paymaster.0xgasless.com/v1/43114/rpc/35b99953-edde-4f28-9661-c41898916471",
                nftContractAddress: "0xe7337B97F380A19A860068f0dACa74F50AF86548",
                explorerUrl: "https://subnets.avax.network/c-chain/tx/",
                nativeCurrency: {
                    name: "AVAX",
                    symbol: "AVAX",
                    decimals: 18
                }
            },
            ETHEREUM: {
                chainId: 1,
                rpcUrl: "https://ethereum-rpc.publicnode.com",
                bundlerUrl: "https://bundler.0xgasless.com/1",
                paymasterUrl: "YOUR_PAYMASTER_URL",
                nftContractAddress: "YOUR_ETHEREUM_CONTRACT",
                explorerUrl: "https://etherscan.io/tx/",
                nativeCurrency: {
                    name: "ETH",
                    symbol: "ETH",
                    decimals: 18
                }
            },
            POLYGON: {
                chainId: 137,
                rpcUrl: "https://polygon-bor-rpc.publicnode.com",
                bundlerUrl: "https://bundler.0xgasless.com/137",
                paymasterUrl: "YOUR_PAYMASTER_URL",
                nftContractAddress: "YOUR_POLYGON_CONTRACT",
                explorerUrl: "https://polygonscan.com/tx/",
                nativeCurrency: {
                    name: "POL",
                    symbol: "POL",
                    decimals: 18
                }
            },
            METIS: {
                chainId: 1088,
                rpcUrl: "https://metis-mainnet.public.blastapi.io",
                bundlerUrl: "https://bundler.0xgasless.com/1088",
                paymasterUrl: "YOUR_PAYMASTER_URL",
                nftContractAddress: "YOUR_METIS_CONTRACT",
                explorerUrl: "https://andromeda.explorer.metis.io/tx/",
                nativeCurrency: {
                    name: "METIS",
                    symbol: "METIS",
                    decimals: 18
                }
            },
            FANTOM: {
                chainId: 250,
                rpcUrl: "https://fantom-rpc.publicnode.com",
                bundlerUrl: "https://bundler.0xgasless.com/250",
                paymasterUrl: "YOUR_PAYMASTER_URL",
                nftContractAddress: "YOUR_FANTOM_CONTRACT",
                explorerUrl: "https://ftmscan.com/tx/",
                nativeCurrency: {
                    name: "FTM",
                    symbol: "FTM",
                    decimals: 18
                }
            }
        };

        let smartWallet;
        let provider;
        let wallet;
        let telegramUser = null;

        window.connectMetamask = async function () {
            try {
                const selectedChain = document.getElementById('chainSelector').value;
                if (!selectedChain) {
                    throw new Error('Please select a network first');
                }

                if (typeof window.ethereum === 'undefined') {
                    throw new Error('Please install MetaMask to use this feature');
                }

                const chainConfig = CHAIN_CONFIG[selectedChain];
                if (!chainConfig) {
                    throw new Error('Invalid network configuration');
                }

                // Switch network first
                await switchNetwork(chainConfig);

                // Request account access
                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts'
                });
                const account = accounts[0];

                // Update provider and wallet
                provider = new ethers.providers.Web3Provider(window.ethereum);
                wallet = provider.getSigner();

                // Update UI
                document.getElementById('walletDetails').innerHTML = `
            <div class="p-4 bg-green-50 rounded-lg">
                <p><strong>Connected Address:</strong> ${account}</p>
                <p><strong>Network:</strong> ${selectedChain}</p>
                <p><strong>Status:</strong> Connected via MetaMask</p>
            </div>
        `;

                // Enable setup button
                document.getElementById('setupBtn').disabled = false;

                return account;
            } catch (error) {
                console.error('Connection error:', error);
                alert(error.message);
                throw error;
            }
        };

        // Function to switch networks in MetaMask
        window.switchNetwork = async function (chainConfig) {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: ethers.utils.hexValue(chainConfig.chainId) }],
                });
            } catch (switchError) {
                // This error code indicates that the chain has not been added to MetaMask
                if (switchError.code === 4902) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [
                                {
                                    chainId: ethers.utils.hexValue(chainConfig.chainId),
                                    chainName: chainConfig.name,
                                    rpcUrls: [chainConfig.rpcUrl],
                                    nativeCurrency: chainConfig.nativeCurrency,
                                    blockExplorerUrls: [chainConfig.explorerUrl.split('/tx/')[0]]
                                }
                            ],
                        });
                    } catch (addError) {
                        console.error('Failed to add network:', addError);
                        throw addError;
                    }
                } else {
                    throw switchError;
                }
            }
        }

        // Add network change listener
        if (window.ethereum) {
            window.ethereum.on('chainChanged', (chainId) => {
                // Reload page when chain changes
                window.location.reload();
            });

            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    // Handle disconnection
                    provider = null;
                    wallet = null;
                    document.getElementById('walletDetails').innerHTML = '';
                    document.getElementById('setupBtn').disabled = true;
                }
            });
        }

        window.createNewWallet = async function () {
            try {
                // Check for Telegram authentication
                console.log("window.telegramUser are : ", window.telegramUser);
                if (!window.telegramUser) {
                    throw new Error('Please login with Telegram first');
                }

                const createWalletBtn = document.getElementById('createWalletBtn');
                const importWalletBtn = document.getElementById('importWalletBtn');
                const setupBtn = document.getElementById('setupBtn');

                createWalletBtn.disabled = true;
                importWalletBtn.disabled = true;

                provider = new ethers.providers.JsonRpcProvider(CONFIG.rpcUrl);
                wallet = ethers.Wallet.createRandom().connect(provider);

                document.getElementById('walletDetails').innerHTML = `
                    <div class="p-4 bg-green-50 rounded-lg">
                        <p><strong>EOA Address:</strong> ${wallet.address}</p>
                        <p><strong>Private Key:</strong> ${wallet.privateKey}</p>
                        <p class="text-red-500 font-bold mt-2">‚ö†Ô∏è Save this private key securely!</p>
                    </div>
                `;

                setupBtn.disabled = false;
                createWalletBtn.disabled = false;
                importWalletBtn.disabled = false;
            } catch (error) {
                alert(`Error creating wallet: ${error.message}`);
                createWalletBtn.disabled = false;
                importWalletBtn.disabled = false;
            }
        };

        window.importWallet = function () {

            if (!window.telegramUser) {
                alert('Please login with Telegram first');
                return;
            }

            const privateKeyInput = document.getElementById('privateKey');
            privateKeyInput.style.display = 'block';
            privateKeyInput.value = '';
            privateKeyInput.focus();

            privateKeyInput.onkeyup = async function (e) {
                if (e.key === 'Enter') {
                    try {
                        const privateKey = privateKeyInput.value.trim();
                        if (!privateKey.startsWith('0x')) {
                            throw new Error('Private key must start with 0x');
                        }

                        provider = new ethers.providers.JsonRpcProvider(CONFIG.rpcUrl);
                        wallet = new ethers.Wallet(privateKey, provider);

                        document.getElementById('walletInfo').innerHTML = `
                            <p><strong>EOA Address:</strong> ${wallet.address}</p>
                            <p><strong>Status:</strong> Wallet imported successfully!</p>
                        `;

                        document.getElementById('setupBtn').disabled = false;
                        privateKeyInput.style.display = 'none';
                    } catch (error) {
                        document.getElementById('walletInfo').innerHTML = `Error: ${error.message}`;
                    }
                }
            }
        }

        window.setupSmartAccount = async function () {
            const setupBtn = document.getElementById('setupBtn');
            try {
                setupBtn.disabled = true;

                if (!wallet) {
                    throw new Error('Please connect wallet first');
                }

                const selectedChain = document.getElementById('chainSelector').value;
                const chainConfig = CHAIN_CONFIG[selectedChain];

                smartWallet = await createSmartAccountClient({
                    signer: wallet,
                    paymasterUrl: chainConfig.paymasterUrl,
                    bundlerUrl: chainConfig.bundlerUrl,
                    chainId: chainConfig.chainId
                });

                const address = await smartWallet.getAddress();

                document.getElementById('smartAccountInfo').innerHTML = `
                <div class="p-4 bg-green-50 rounded-lg">
                    <p><strong>Network:</strong> ${chainConfig.name}</p>
                    <p><strong>Smart Account:</strong> ${address}</p>
                    <p><strong>Status:</strong> Ready for transactions</p>
                </div>
            `;

                document.getElementById('nftCreation').style.display = 'block';
                document.getElementById('nftDetails').style.display = 'block';

            } catch (error) {
                console.error('Smart Account Setup Error:', error);
                document.getElementById('smartAccountInfo').innerHTML = `
                <div class="p-4 bg-red-50 rounded-lg text-red-600">
                    Error: ${error.message}
                </div>
            `;
                setupBtn.disabled = false;
            }
        };

        window.generateArtwork = async function () {
            try {
                const generateBtn = document.getElementById('generateBtn');
                generateBtn.disabled = true;

                const prompt = document.getElementById('promptInput').value;
                const style = document.getElementById('styleSelect').value;

                if (!prompt) {
                    throw new Error('Please enter a description for your artwork');
                }

                // Format the prompt based on the selected style
                const formattedPrompt = formatPrompt(prompt, style);
                console.log("formattedPrompt are : ", formattedPrompt);

                // Call Stable Diffusion API
                // const response = await fetch('https://api-inference.huggingface.co/models/black-forest-labs/FLUX.1-dev', {
                const response = await fetch('https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/text-to-image', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer sk-H0mnieWsiXOPiGUkJLR3SUYXxu8Bm1mBaVJlXtAHnoNpYY0c`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        "text_prompts": [
                            {
                                "text": formattedPrompt,
                                "weight": 1
                            }
                        ],
                        "cfg_scale": 7,
                        "height": 1024,
                        "width": 1024,
                        "samples": 1,
                        "steps": 30,
                        "style_preset": style.toLowerCase()
                    })
                });
                console.log("respose are : ", response);

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to generate image');
                }

                // const blob = await response.blob();
                // const imageUrl = URL.createObjectURL(blob);
                const result = await response.json();

                // Stability AI returns base64 image data
                const image = result.artifacts[0];
                const imageUrl = `data:image/png;base64,${image.base64}`;

                // Update the preview image
                const imageElement = document.getElementById('artworkPreview');
                imageElement.src = imageUrl;
                imageElement.setAttribute('data-image-id', image.id); // Store image ID for reference

                // Get AI-recommended price based on style and complexity
                const recommendedPrice = await getRecommendedPrice();
                document.getElementById('priceRecommendation').textContent =
                    `ü§ñ AI Recommended Price: ${recommendedPrice} ETH`;

                // Enable the mint button after successful generation
                document.getElementById('mintBtn').disabled = false;

            } catch (error) {
                console.error("Error generating artwork:", error);
                alert(`Failed to generate artwork: ${error.message}`);
            } finally {
                generateBtn.disabled = false;
            }
        };

        // Helper function to format prompts based on style
        function formatPrompt(prompt, style) {
            const stylePrompts = {
                'realistic': `${prompt}, ultra realistic photograph, professional photography, 8k uhd, high detail`,
                'enhance': `${prompt}, enhanced, artistic, professional quality`,
                'anime': `${prompt}, anime style, manga art`,
                'photographic': `${prompt}, professional photography, high resolution`,
                'digital-art': `${prompt}, digital art, concept art, detailed, vibrant`,
                'comic-book': `${prompt}, comic book style, illustrated, vibrant colors`
            };

            return stylePrompts[style.toLowerCase()] || prompt;
        }

        async function uploadToIPFS(metadata) {
            try {
                // Get the image from the preview
                const imageElement = document.getElementById('artworkPreview');
                const imageUrl = imageElement.src;

                // Convert base64 image to blob
                const base64Response = await fetch(imageUrl);
                const blob = await base64Response.blob();

                // Create form data for image
                const imageFormData = new FormData();
                imageFormData.append('file', blob, 'artwork.png');

                // Upload image to Pinata
                const imageResponse = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${CONFIG.pinata.jwt}`
                    },
                    body: imageFormData
                });

                if (!imageResponse.ok) {
                    const errorData = await imageResponse.json();
                    console.error('Pinata Image Upload Error:', errorData);
                    throw new Error(`Failed to upload image: ${errorData.message || 'Unknown error'}`);
                }

                const imageData = await imageResponse.json();
                console.log('Image uploaded to IPFS:', imageData);

                // Update metadata with IPFS image URL
                metadata.image = `ipfs://${imageData.IpfsHash}`;

                // Prepare metadata for upload
                const metadataJSON = JSON.stringify({
                    pinataOptions: {
                        cidVersion: 1
                    },
                    pinataMetadata: {
                        name: metadata.name,
                        keyvalues: {
                            type: "AI NFT Metadata"
                        }
                    },
                    pinataContent: metadata
                });

                // Upload metadata to Pinata
                const metadataResponse = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${CONFIG.pinata.jwt}`
                    },
                    body: metadataJSON
                });

                if (!metadataResponse.ok) {
                    const errorData = await metadataResponse.json();
                    console.error('Pinata Metadata Upload Error:', errorData);
                    throw new Error(`Failed to upload metadata: ${errorData.message || 'Unknown error'}`);
                }

                const metadataResult = await metadataResponse.json();
                console.log('Metadata uploaded to IPFS:', metadataResult);

                return `ipfs://${metadataResult.IpfsHash}`;
            } catch (error) {
                console.error('IPFS Upload Error:', error);
                throw error;
            }
        }

        window.mintNFT = async function () {
            const mintBtn = document.getElementById('mintBtn');
            const transactionStatus = document.getElementById('transactionStatus');
            const transactionHash = document.getElementById('transactionHash');
            const statusText = document.getElementById('statusText');

            try {
                // Validate smart wallet
                if (!smartWallet) {
                    throw new Error('Smart wallet not initialized. Please set up your smart account first.');
                }

                mintBtn.disabled = true;

                // Validate input fields
                const name = document.getElementById('nftName').value.trim();
                const description = document.getElementById('nftDescription').value.trim();
                const price = document.getElementById('basePrice').value;
                const collaborator = document.getElementById('collaboratorAddress').value.trim();
                const royalty = document.getElementById('royaltyPercentage').value;

                if (!name || !description) {
                    throw new Error('Please fill in name and description');
                }

                // Display status
                transactionStatus.style.display = 'block';
                statusText.textContent = 'Uploading to IPFS...';

                // Create and upload metadata
                const metadata = await createNFTMetadata(name, description);
                const tokenURI = await uploadToIPFS(metadata);

                statusText.textContent = 'Preparing transaction...';

                // Create proper contract interfaces
                const provider = new ethers.providers.JsonRpcProvider(CONFIG.rpcUrl);

                // Create interface for encoding
                const nftInterface = new ethers.utils.Interface(nftABI);
                const data = nftInterface.encodeFunctionData("mintNFT", [tokenURI]);

                console.log("TokenURI:", tokenURI);
                console.log("Encoded function data:", data);

                // Prepare transaction
                const tx = {
                    to: CONFIG.nftContractAddress,
                    data: data,
                    value: ethers.utils.parseEther("0"),
                    gasLimit: ethers.utils.hexlify(500000)
                };

                console.log("Transaction object:", tx);

                try {
                    statusText.textContent = 'Sending transaction...';

                    // Send transaction through smart account
                    const userOpResponse = await smartWallet.sendTransaction(tx, {
                        paymasterServiceData: {
                            mode: PaymasterMode.SPONSORED
                        }
                    });

                    console.log("Transaction submitted:", userOpResponse);

                    // Wait for transaction hash
                    const txHash = await userOpResponse.waitForTxHash();
                    console.log("Transaction hash received:", txHash);

                    if (!txHash) {
                        throw new Error("Failed to get transaction hash");
                    }

                    transactionStatus.textContent = 'Minting in progress...';
                    transactionHash.innerHTML = `
                        Transaction Hash: <a href="${getExplorerUrl(txHash)}" 
                        target="_blank" class="underline">${txHash}</a>
                    `;

                    // Wait for confirmation
                    statusText.textContent = 'Waiting for confirmation...';
                    const receipt = await provider.waitForTransaction(txHash);
                    console.log("Transaction receipt:", receipt);

                    if (receipt.status === 1) {
                        // Handle successful mint
                        statusText.innerHTML = `
                    <div class="text-green-600">
                        ‚úÖ NFT Minted Successfully!<br>
                        Name: ${name}<br>
                        ${price ? `Price: ${price} ETH<br>` : ''}
                        ${collaborator ? `Collaborator: ${collaborator} (${royalty}%)` : ''}
                    </div>
                `;

                        // Set royalties if needed
                        if (collaborator && royalty) {
                            try {
                                // Get tokenId from events
                                const nftContract = new ethers.Contract(CONFIG.nftContractAddress, nftABI, provider);
                                const events = await nftContract.queryFilter(nftContract.filters.NFTMinted(), receipt.blockNumber, receipt.blockNumber);
                                const tokenId = events[0].args.tokenId;

                                // Set royalties
                                const royaltyTx = await smartWallet.sendTransaction({
                                    to: CONFIG.nftContractAddress,
                                    data: nftInterface.encodeFunctionData("setRoyalties", [tokenId, collaborator, royalty]),
                                    value: ethers.utils.parseEther("0")
                                }, {
                                    paymasterServiceData: {
                                        mode: PaymasterMode.SPONSORED
                                    }
                                });

                                await royaltyTx.wait();
                            } catch (royaltyError) {
                                console.error("Failed to set royalties:", royaltyError);
                            }
                        }

                        transactionHash.innerHTML += `
                    <br>View your NFT on: <a href="https://nft.avax.network/collection/${CONFIG.nftContractAddress}" 
                    target="_blank" class="underline">Avalanche NFT Marketplace</a>
                `;
                    } else {
                        throw new Error('Transaction failed');
                    }

                } catch (txError) {
                    console.error('Transaction error:', txError);
                    // Handle specific transaction errors
                    if (txError.message.includes('user denied')) {
                        throw new Error('Transaction was rejected');
                    } else if (txError.message.includes('insufficient funds')) {
                        throw new Error('Insufficient funds for transaction');
                    } else {
                        throw new Error(`Transaction failed: ${txError.message}`);
                    }
                }

            } catch (error) {
                console.error('Minting error:', error);
                if (statusText) {
                    statusText.innerHTML = `
                <div class="text-red-600">
                    ‚ùå Error: ${error.message}
                </div>
            `;
                }
            } finally {
                if (mintBtn) {
                    mintBtn.disabled = false;
                }
            }
        };

        // NFT Contract ABI
        const nftABI = [
            {
                "inputs": [],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "sender",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    }
                ],
                "name": "ERC721IncorrectOwner",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "operator",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "ERC721InsufficientApproval",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "approver",
                        "type": "address"
                    }
                ],
                "name": "ERC721InvalidApprover",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "operator",
                        "type": "address"
                    }
                ],
                "name": "ERC721InvalidOperator",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    }
                ],
                "name": "ERC721InvalidOwner",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "receiver",
                        "type": "address"
                    }
                ],
                "name": "ERC721InvalidReceiver",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "sender",
                        "type": "address"
                    }
                ],
                "name": "ERC721InvalidSender",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "ERC721NonexistentToken",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    }
                ],
                "name": "OwnableInvalidOwner",
                "type": "error"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "OwnableUnauthorizedAccount",
                "type": "error"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "approved",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "Approval",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "operator",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "bool",
                        "name": "approved",
                        "type": "bool"
                    }
                ],
                "name": "ApprovalForAll",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "_fromTokenId",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "_toTokenId",
                        "type": "uint256"
                    }
                ],
                "name": "BatchMetadataUpdate",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "_tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "MetadataUpdate",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "string",
                        "name": "uri",
                        "type": "string"
                    }
                ],
                "name": "NFTMinted",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "previousOwner",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "newOwner",
                        "type": "address"
                    }
                ],
                "name": "OwnershipTransferred",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "collaborator",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "percentage",
                        "type": "uint256"
                    }
                ],
                "name": "RoyaltySet",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "from",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "to",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "Transfer",
                "type": "event"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "to",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "approve",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    }
                ],
                "name": "balanceOf",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "burn",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "getApproved",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "getRoyaltyInfo",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getTokenCounter",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "owner",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "operator",
                        "type": "address"
                    }
                ],
                "name": "isApprovedForAll",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "string",
                        "name": "uri",
                        "type": "string"
                    }
                ],
                "name": "mintNFT",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "name",
                "outputs": [
                    {
                        "internalType": "string",
                        "name": "",
                        "type": "string"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "owner",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "ownerOf",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "renounceOwnership",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "from",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "to",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "safeTransferFrom",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "from",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "to",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bytes",
                        "name": "data",
                        "type": "bytes"
                    }
                ],
                "name": "safeTransferFrom",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "operator",
                        "type": "address"
                    },
                    {
                        "internalType": "bool",
                        "name": "approved",
                        "type": "bool"
                    }
                ],
                "name": "setApprovalForAll",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "collaborator",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "percentage",
                        "type": "uint256"
                    }
                ],
                "name": "setRoyalties",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes4",
                        "name": "interfaceId",
                        "type": "bytes4"
                    }
                ],
                "name": "supportsInterface",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "symbol",
                "outputs": [
                    {
                        "internalType": "string",
                        "name": "",
                        "type": "string"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "tokenURI",
                "outputs": [
                    {
                        "internalType": "string",
                        "name": "",
                        "type": "string"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "from",
                        "type": "address"
                    },
                    {
                        "internalType": "address",
                        "name": "to",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "transferFrom",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "newOwner",
                        "type": "address"
                    }
                ],
                "name": "transferOwnership",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];

        // Helper function to validate Ethereum address
        function isValidAddress(address) {
            try {
                ethers.utils.getAddress(address);
                return true;
            } catch {
                return false;
            }
        }

        // Helper function to create metadata
        async function createNFTMetadata(name, description) {
            const style = document.getElementById('styleSelect').value;
            return {
                name: name,
                description: description,
                image: "", // Will be updated after IPFS upload
                attributes: [
                    {
                        trait_type: "Style",
                        value: style
                    },
                    {
                        trait_type: "Generator",
                        value: "Stable Diffusion XL"
                    },
                    {
                        display_type: "date",
                        trait_type: "Created",
                        value: Math.floor(Date.now() / 1000)
                    }
                ]
            };
        }

        // async function handleNetworkSelection(chainValue) {
        //     const chainConfig = CHAIN_CONFIG[chainValue];
        //     if (!chainConfig) {
        //         throw new Error('Please select a valid network');
        //     }

        //     // Update the display
        //     document.getElementById('networkDisplay').textContent = chainValue;

        //     // Reset connections if exist
        //     if (window.ethereum && window.ethereum.isConnected()) {
        //         provider = null;
        //         wallet = null;
        //         smartWallet = null;
        //         document.getElementById('walletDetails').innerHTML = '';
        //         document.getElementById('smartAccountInfo').innerHTML = '';
        //         document.getElementById('setupBtn').disabled = true;
        //     }

        //     // Update global config
        //     CONFIG = {
        //         ...CONFIG,
        //         rpcUrl: chainConfig.rpcUrl,
        //         bundlerUrl: chainConfig.bundlerUrl,
        //         paymasterUrl: chainConfig.paymasterUrl,
        //         chainId: chainConfig.chainId,
        //         nftContractAddress: chainConfig.nftContractAddress
        //     };

        //     return chainConfig;
        // }

        // Initialize price recommendation system
        async function getRecommendedPrice() {
            // In a real implementation, this would use AI to analyze similar NFTs
            // For now, we'll return a random price
            const basePrice = 0.05;
            const variance = Math.random() * 0.1 - 0.05;
            return (basePrice + variance).toFixed(3);
        }

        // Setup event listeners for input validation
        document.getElementById('collaboratorAddress').addEventListener('input', function (e) {
            const address = e.target.value;
            if (address && !isValidAddress(address)) {
                e.target.style.borderColor = '#ef4444';
            } else {
                e.target.style.borderColor = '#e5e7eb';
            }
        });

        document.getElementById('royaltyPercentage').addEventListener('input', function (e) {
            const value = parseFloat(e.target.value);
            if (isNaN(value) || value < 0 || value > 100) {
                e.target.style.borderColor = '#ef4444';
            } else {
                e.target.style.borderColor = '#e5e7eb';
            } 1
        });

        document.getElementById('chainSelector').addEventListener('change', debounce(async (e) => {
            try {
                const chainValue = e.target.value;
                const networkDisplay = document.getElementById('networkDisplay');

                // Immediate UI feedback
                requestAnimationFrame(() => {
                    networkDisplay.textContent = chainValue || 'Not Selected';
                    document.getElementById('connectMetamaskBtn').disabled = !chainValue;
                });

                if (!chainValue) {
                    return;
                }

                const chainConfig = CHAIN_CONFIG[chainValue];
                if (!chainConfig) {
                    throw new Error('Invalid network configuration');
                }

                // Update CONFIG object
                CONFIG = {
                    ...CONFIG,
                    rpcUrl: chainConfig.rpcUrl,
                    bundlerUrl: chainConfig.bundlerUrl,
                    paymasterUrl: chainConfig.paymasterUrl,
                    chainId: chainConfig.chainId,
                    nftContractAddress: chainConfig.nftContractAddress
                };

                // Update UI elements
                requestAnimationFrame(() => {
                    // Update currency symbol
                    const currencySymbol = document.getElementById('currencySymbol');
                    if (currencySymbol) {
                        currencySymbol.textContent = chainConfig.nativeCurrency.symbol;
                    }

                    // Reset wallet states if connected
                    if (window.ethereum?.isConnected()) {
                        provider = null;
                        wallet = null;
                        smartWallet = null;

                        // Reset UI elements
                        const elements = {
                            walletDetails: { innerHTML: '' },
                            smartAccountInfo: { innerHTML: '' },
                            setupBtn: { disabled: true },
                            nftCreation: { style: { display: 'none' } },
                            nftDetails: { style: { display: 'none' } }
                        };

                        Object.entries(elements).forEach(([id, props]) => {
                            const element = document.getElementById(id);
                            if (element) {
                                Object.entries(props).forEach(([prop, value]) => {
                                    if (prop === 'style') {
                                        Object.assign(element.style, value);
                                    } else {
                                        element[prop] = value;
                                    }
                                });
                            }
                        });
                    }
                });

            } catch (error) {
                console.error('Network switch error:', error);
                requestAnimationFrame(() => {
                    e.target.value = '';
                    networkDisplay.textContent = 'Not Selected';
                    document.getElementById('connectMetamaskBtn').disabled = true;
                    alert(error.message);
                });
            }
        }, 250));

        // Add loading indicators
        function setLoading(elementId, isLoading) {
            const element = document.getElementById(elementId);
            if (isLoading) {
                element.classList.add('loading');
            } else {
                element.classList.remove('loading');
            }
        }

        function getExplorerUrl(txHash) {
            const selectedChain = document.getElementById('chainSelector').value;
            const chainConfig = CHAIN_CONFIG[selectedChain];
            return `${chainConfig.explorerUrl}${txHash}`;
        }

        // Initialize tooltips
        const tooltips = document.querySelectorAll('[data-tooltip]');
        tooltips.forEach(element => {
            element.addEventListener('mouseenter', e => {
                const tooltip = document.createElement('div');
                tooltip.className = 'absolute bg-gray-800 text-white p-2 rounded text-sm';
                tooltip.textContent = e.target.dataset.tooltip;
                document.body.appendChild(tooltip);

                const rect = e.target.getBoundingClientRect();
                tooltip.style.left = rect.left + 'px';
                tooltip.style.top = (rect.bottom + 5) + 'px';

                e.target.addEventListener('mouseleave', () => tooltip.remove());
            });
        });

        window.showFeedback = function () {
            // You can customize this function based on how you want to handle feedback
            const message = prompt('Please share your feedback:');
            if (message) {
                alert('Thank you for your feedback!');
                // Here you could send the feedback to a server or handle it in another way
                console.log('Feedback received:', message);
            }
        };

    </script>

    <!-- Add a global error boundary -->
    <div id="errorBoundary"
        class="fixed bottom-4 right-4 max-w-sm bg-red-100 border-l-4 border-red-500 text-red-700 p-4"
        style="display: none;">
        <div class="flex">
            <div class="py-1">
                <svg class="h-6 w-6 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            </div>
            <div class="ml-3">
                <p class="text-sm" id="errorMessage"></p>
            </div>
        </div>
    </div>

    <!-- Add a feedback widget -->
    <div class="fixed bottom-4 left-4">
        <button onclick="showFeedback()"
            class="bg-purple-600 text-white rounded-full p-3 shadow-lg hover:bg-purple-700 transition-colors">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" />
            </svg>
        </button>
    </div>

</body>

</html>